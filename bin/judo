#!/usr/bin/env ruby

require 'optparse'
require File.dirname(__FILE__) + '/../lib/judo'
require File.dirname(__FILE__) + '/../lib/judo/commandline_helpers'

include JudoCommandLineHelpers

defaults = Judo::Base.default_options(Dir.pwd)

options = {}

action = ARGV.shift

ARGV.unshift "-h" unless action

optparse = OptionParser.new do|opts|
  opts.banner = <<banner
Usage: judo launch [options] SERVER ...
       judo create [options] SERVER ...
       judo destroy [options] SERVER ...

       # SERVER can be formatted as NAME or NAME:GROUP or +N or +N:GROUP
       # where N is the number of servers to create or launch
       # 'launch' only differs from 'create' in that it immediately starts the server

       judo start [options] [SERVER ...]
       judo stop [options] [SERVER ...]
       judo restart [options] [SERVER ...]

       judo commit [options] GROUP

       judo info [options] [SERVER ...]
       judo console [options] [SERVER ...] ## shows AWS console output
       judo ssh [options] [SERVER ...]     ## ssh's into the server

       # SERVER can be formatted as NAME or NAME:GROUP
       # or :GROUP to indicate the whole group.
       # If no servers are listed all servers are assumed.

       judo list [options]    ## lists all servers
       judo groups [options]  ## lists all groups

       judo volumes [options] ## shows all EBS volumes and what they are attached to
       judo ips [options]     ## shows all elastic ips and what they are attached to

banner

  # start stop create destroy launch restart info console
  # list volumes ips

  opts.on( '-c', '--config DIR', 'Specify the location of the config dir' ) do |dir|
    defaults[:judo_dir] = dir
    defaults.merge(Judo::Base.default_options(Dir.pwd, dir))
  end
  opts.on( '-r', '--repo DIR', 'Specify the location of the repo dir' ) do |dir|
    options[:repo] = dir
  end
  opts.on( '-a', '--accessid ID', 'Specify the AWS access ID' ) do |id|
    options[:access_id] = id
  end
  opts.on( '-s', '--secret KEY', 'Specify the AWS access secret key' ) do |key|
    options[:access_key] = key
  end
  opts.on( '-b', '--bucket BUCKET', 'Specify the AWS S3 bucket to use' ) do |bucket|
    options[:bucket] = bucket
  end
  opts.on( '-g', '--group GROUP', 'Specify the default group of the repo dir' ) do |group|
    options[:group] = group
  end
  opts.on( '-v', '--version VERSION', 'Update the servers config version on create/start/launch' ) do |version|
    options[:version] = version
  end
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end

optparse.parse!

judo = Judo::Base.new(defaults.merge(options))

begin
  case action
    when "ips" then do_ips(judo)
    when "volumes" then do_volumes(judo)
    when "list" then do_list(judo, ARGV)
    when "groups" then do_groups(judo)
    when "info" then find_servers(judo, ARGV)         { |s| do_info(judo, s) }
    when "console" then find_servers(judo, ARGV)      { |s| puts s.console_output }
    when "commit" then find_groups(judo, ARGV)        { |g| g.compile }
    when "ssh" then find_servers(judo, ARGV)          { |s| s.connect_ssh }
    when "start" then find_servers(judo, ARGV)        { |s| s.start(options[:version]) }
    when "restart" then find_servers(judo, ARGV)      { |s| s.restart }
    when "stop" then find_servers(judo, ARGV)         { |s| s.stop }
    when "create" then mk_servers(judo, ARGV)         { |s| s.create(options[:version]) }
    when "launch" then mk_servers(judo, ARGV)         { |s| s.create(options[:version]); s.start }
    when "destroy" then
      raise JudoError, "You must specify what servers to destroy" if ARGV.empty?
      find_either(judo, ARGV) do |i|
        i.destroy
      end
    else
      raise JudoError, "No such action #{action}"
  end
rescue JudoError => e
  puts "Error: #{e.message}"
  exit 1
end
